// src/integrations/radar.ts
import axios from "axios";
import Radar from "radar-sdk-js";

// Load both keys from env
const RADAR_SECRET_KEY = process.env.RADAR_SECRET_KEY!;
const RADAR_PUBLISHABLE_KEY = process.env.RADAR_PUBLISHABLE_KEY!;

// Initialize Radar Web SDK (call this once in your app)
export const initializeRadar = () => {
  Radar.initialize(RADAR_PUBLISHABLE_KEY);
};

/**
 * BACKEND API FUNCTIONS (using secret key)
 */

async function createTrip(data: {
  externalId: string;
  destinationGeofenceTag?: string;
  destinationGeofenceExternalId?: string;
  userId?: string;
  mode?: "foot" | "bike" | "car";
  approachingThreshold?: number;
  scheduledArrivalAt?: string;
  metadata?: Record<string, any>;
}) {
  const res = await axios.post("https://api.radar.io/v1/trips", data, {
    headers: { Authorization: `Bearer ${RADAR_SECRET_KEY}` },
  });
  return res.data;
}

async function getTrip(idOrExternalId: string, includeLocations = true) {
  const res = await axios.get(`https://api.radar.io/v1/trips/${idOrExternalId}`, {
    headers: { Authorization: `Bearer ${RADAR_SECRET_KEY}` },
    params: { includeLocations },
  });
  return res.data;
}

async function deleteTrip(idOrExternalId: string) {
  const res = await axios.delete(`https://api.radar.io/v1/trips/${idOrExternalId}`, {
    headers: { Authorization: `Bearer ${RADAR_SECRET_KEY}` },
  });
  return res.data;
}

async function updateTrip(
  idOrExternalId: string,
  data: {
    status: "pending" | "started" | "approaching" | "arrived" | "completed" | "canceled";
    mode?: "foot" | "bike" | "car";
    destinationGeofenceTag?: string;
    destinationGeofenceExternalId?: string;
    approachingThreshold?: number;
    scheduledArrivalAt?: string;
    metadata?: Record<string, any>;
  }
) {
  const res = await axios.patch(
    `https://api.radar.io/v1/trips/${idOrExternalId}/update`,
    data,
    {
      headers: { Authorization: `Bearer ${RADAR_SECRET_KEY}` }, // Fixed: use secret key
    }
  );
  return res.data;
}

/**
 * FRONTEND WEB SDK FUNCTIONS
 */

// Set user ID for tracking
export const setUserId = (userId: string) => {
  Radar.setUserId(userId);
};

// Track location once and update Radar
export const trackLocationOnce = async () => {
  try {
    const result = await Radar.trackOnce();
    const { location, user, events } = result;
    return {
      latitude: location.coordinates[1], // Radar returns [lng, lat]
      longitude: location.coordinates[0],
      location,
      user,
      events
    };
  } catch (error) {
    console.error('Location tracking error:', error);
    throw error;
  }
};

// Start continuous location tracking every 30 seconds
export const startLocationTracking = (onLocationUpdate: (coords: { latitude: number; longitude: number }) => void) => {
  const trackingInterval = setInterval(async () => {
    try {
      const result = await trackLocationOnce();
      onLocationUpdate({
        latitude: result.latitude,
        longitude: result.longitude
      });
    } catch (error) {
      console.error('Tracking error:', error);
    }
  }, 30000); // Every 30 seconds

  return trackingInterval; // Return interval ID to clear later
};

// Stop location tracking
export const stopLocationTracking = (intervalId: NodeJS.Timeout) => {
  clearInterval(intervalId);
};

/**
 * COMPLETE TRIP WORKFLOW
 */

export const tripWorkflow = {
  // 1. Start a trip
  async startTrip(tripData: {
    externalId: string;
    userId: string;
    mode?: "foot" | "bike" | "car";
    destinationGeofenceTag?: string;
    destinationGeofenceExternalId?: string;
  }) {
    // Set user ID for Web SDK
    setUserId(tripData.userId);
    
    // Create trip via backend
    const trip = await createTrip(tripData);
    
    // Start location tracking
    const trackingInterval = startLocationTracking((coords) => {
      console.log('Location updated:', coords);
      // You can update your Leaflet map here
      // updateMapMarker(coords.latitude, coords.longitude);
    });
    
    return { trip, trackingInterval };
  },

  // 2. Get trip updates (call every 30s to get latest data)
  async getTripUpdates(externalId: string) {
    return await getTrip(externalId, true); // Include locations
  },

  // 3. End trip
  async endTrip(externalId: string, trackingInterval: NodeJS.Timeout) {
    // Stop location tracking
    stopLocationTracking(trackingInterval);
    
    // Delete trip
    const result = await deleteTrip(externalId);
    
    return result;
  }
};

/**
 * Export everything you need
 */
export const radar = {
  // Initialize
  initialize: initializeRadar,
  
  // Trip management
  trips: {
    createTrip,
    getTrip,
    deleteTrip,
    updateTrip,
  },
  
  // Location tracking
  location: {
    setUserId,
    trackOnce: trackLocationOnce,
    startTracking: startLocationTracking,
    stopTracking: stopLocationTracking,
  },
  
  // Complete workflow
  workflow: tripWorkflow,
};



//===========journey tracker now================
// src/pages/JourneyTracker.tsx - FIXED to use global user
import React, { useState, useEffect, useRef } from 'react';
import { useAppStore } from "@/components/ReusableUI";
import JourneyMap, { JourneyMapRef } from '@/components/journey-map';

import { 
  ModernJourneyHeader,
  ModernTripPlanningCard,
  ModernActiveTripCard,
  ModernCompletedTripCard,
  ModernMessageCard
} from '@/components/ReusableUI';

interface Dealer {
  id: string;
  name: string;
  address: string;
  latitude: number;
  longitude: number;
}

interface Location {
  lat: number;
  lng: number;
  address?: string;
}

interface TripData {
  journeyId: string;
  dbJourneyId: number;
  dealer: Dealer;
  radarTrip: any;
}

export default function JourneyTracker({ onBack }: { onBack?: () => void }) {
  // ðŸ‘‡ global user from Zustand
  const { user } = useAppStore();
  const userId = user?.id;

  const [currentLocation, setCurrentLocation] = useState<Location | null>(null);
  const [selectedDealer, setSelectedDealer] = useState<Dealer | null>(null);
  const [dealers, setDealers] = useState<Dealer[]>([]);
  const [isLoadingLocation, setIsLoadingLocation] = useState(false);
  const [tripStatus, setTripStatus] = useState<'idle' | 'active' | 'completed'>('idle');
  const [activeTripData, setActiveTripData] = useState<TripData | null>(null);
  const [distance, setDistance] = useState(0);
  const [duration, setDuration] = useState(0);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');
  const [showDestinationChange, setShowDestinationChange] = useState(false);
  const [routePolyline, setRoutePolyline] = useState<[number, number][]>([]);

  const mapRef = useRef<JourneyMapRef>(null);
  const trackingIntervalRef = useRef<NodeJS.Timeout | null>(null);

  // Fetch dealers only when userId is ready
  useEffect(() => {
    if (!userId) return;
    const fetchDealers = async () => {
      try {
        const response = await fetch(`/api/dealers/user/${userId}`);
        const data = await response.json();
        if (data.success) setDealers(data.data || []);
      } catch {
        setError('Failed to load dealers');
      }
    };
    fetchDealers();
  }, [userId]);


  // Get current location
  const getCurrentLocation = async () => {
    setIsLoadingLocation(true);
    try {
      const position = await new Promise<GeolocationPosition>((resolve, reject) => {
        navigator.geolocation.getCurrentPosition(resolve, reject, {
          enableHighAccuracy: true,
          timeout: 10000,
          maximumAge: 60000
        });
      });

      const location = {
        lat: position.coords.latitude,
        lng: position.coords.longitude,
        address: 'Current Location'
      };

      setCurrentLocation(location);

      if (mapRef.current) {
        mapRef.current.setView(location.lat, location.lng, 15);
      }
    } catch (err) {
      setError('Unable to get location. Please enable GPS.');
    } finally {
      setIsLoadingLocation(false);
    }
  };

  // Start trip
  const startTrip = async () => {
    if (!currentLocation || !selectedDealer) {
      setError('Please select location and destination');
      return;
    }

    try {
      const response = await fetch('/api/geo/start', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userId,
          dealerId: selectedDealer.id,
          lat: currentLocation.lat,
          lng: currentLocation.lng
        })
      });

      const data = await response.json();
      if (data.success) {
        setActiveTripData({
          journeyId: data.data.radarTrip._id,
          dbJourneyId: data.data.dbJourneyId,
          dealer: data.data.dealer,
          radarTrip: data.data.radarTrip
        });
        setTripStatus('active');
        setSuccess('Journey started! ðŸš—');
        startLocationTracking(data.data.radarTrip._id);
      } else {
        setError(data.error || 'Failed to start trip');
      }
    } catch (err) {
      setError('Network error');
    }
  };

  // Location tracking every 27 seconds
  const startLocationTracking = (journeyId: string) => {
    trackingIntervalRef.current = setInterval(async () => {
      try {
        const position = await new Promise<GeolocationPosition>((resolve, reject) => {
          navigator.geolocation.getCurrentPosition(resolve, reject, {
            enableHighAccuracy: true,
            timeout: 5000
          });
        });

        const newLocation = {
          lat: position.coords.latitude,
          lng: position.coords.longitude
        };

        setCurrentLocation(newLocation);

        // Fetch updated trip data
        const response = await fetch(`/api/geo/trips/${journeyId}`);
        const data = await response.json();

        if (data.success) {
          const trip = data.data.radarTrip;

          if (trip.distance && trip.duration) {
            setDistance(trip.distance.value || 0);
            setDuration(trip.duration.value || 0);
          }

          if (trip.locations && trip.locations.length > 0) {
            const polylinePoints = trip.locations.map((loc: any) => [
              loc.coordinates[1],
              loc.coordinates[0]
            ]);
            setRoutePolyline(polylinePoints);
          }
        }
      } catch (err) {
        console.error('Tracking error:', err);
      }
    }, 27000);
  };

  // Change destination
  const changeDestination = async (newDealerId: string) => {
    if (!activeTripData) return;

    try {
      const response = await fetch(`/api/geo/trips/${activeTripData.journeyId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          destinationGeofenceExternalId: newDealerId,
          status: "destination_updated"
        })
      });

      const data = await response.json();
      if (data.success) {
        const newDealer = dealers.find(d => d.id === newDealerId);
        if (newDealer) {
          setSelectedDealer(newDealer);
          setActiveTripData(prev => prev ? {
            ...prev,
            dealer: newDealer,
            radarTrip: data.data
          } : null);
          setSuccess('Destination updated! ðŸŽ¯');
          setShowDestinationChange(false);
          setRoutePolyline([]);
        }
      } else {
        setError(data.error || 'Failed to update');
      }
    } catch (err) {
      setError('Failed to change destination');
    }
  };

  // Complete trip
  const completeTrip = async () => {
    if (!activeTripData) return;

    try {
      const response = await fetch(`/api/geo/finish/${activeTripData.journeyId}`, {
        method: 'POST'
      });

      const data = await response.json();
      if (data.success) {
        setTripStatus('completed');
        setSuccess('Journey completed! ðŸŽ‰');

        if (trackingIntervalRef.current) {
          clearInterval(trackingIntervalRef.current);
          trackingIntervalRef.current = null;
        }
      } else {
        setError('Failed to complete trip');
      }
    } catch (err) {
      setError('Failed to complete trip');
    }
  };

  // Reset for new journey
  const startNewJourney = () => {
    setTripStatus('idle');
    setActiveTripData(null);
    setSelectedDealer(null);
    setDistance(0);
    setDuration(0);
    setRoutePolyline([]);
    setShowDestinationChange(false);
  };

  // Auto-hide messages
  useEffect(() => {
    if (success || error) {
      const timer = setTimeout(() => {
        setSuccess('');
        setError('');
      }, 4000);
      return () => clearTimeout(timer);
    }
  }, [success, error]);

  // Initialize
  useEffect(() => {
    getCurrentLocation();

    return () => {
      if (trackingIntervalRef.current) {
        clearInterval(trackingIntervalRef.current);
      }
    };
  }, []);

  return (
    <div className="min-h-screen bg-background">
      {/* Header */}
      <ModernJourneyHeader status={tripStatus} onBack={onBack} />

      {/* Messages */}
      {success && <ModernMessageCard type="success" message={success} />}
      {error && <ModernMessageCard type="error" message={error} />}

      {/* Main Content - Clean Layout */}
      <div className="container max-w-md mx-auto p-4 space-y-4">
        {/* Contained Map */}
        <JourneyMap
          ref={mapRef}
          currentLocation={currentLocation}
          selectedDealer={selectedDealer}
          routePolyline={routePolyline}
          className="w-full"
        />

        {/* Trip UI Cards */}
        {tripStatus === 'idle' && (
          <ModernTripPlanningCard
            currentLocation={currentLocation?.address}
            selectedDealer={selectedDealer}
            dealers={dealers}
            isLoadingLocation={isLoadingLocation}
            onGetCurrentLocation={getCurrentLocation}
            onDealerSelect={(dealerId) => {
              const dealer = dealers.find(d => d.id === dealerId);
              setSelectedDealer(dealer || null);
            }}
            onStartTrip={startTrip}
          />
        )}

        {tripStatus === 'active' && activeTripData && (
          <ModernActiveTripCard
            dealer={activeTripData.dealer}
            distance={distance}
            duration={duration}
            onChangeDestination={() => setShowDestinationChange(true)}
            onCompleteTrip={completeTrip}
            showDestinationChange={showDestinationChange}
            dealers={dealers}
            onDestinationChange={changeDestination}
            onCancelChange={() => setShowDestinationChange(false)}
          />
        )}

        {tripStatus === 'completed' && (
          <ModernCompletedTripCard
            distance={distance}
            duration={duration}
            onStartNew={startNewJourney}
          />
        )}
      </div>
    </div>
  );
}

// src/pages/JourneyTracker.tsx - FIXED to use global user
import React, { useState, useEffect, useRef } from 'react';
import { useAppStore } from "@/components/ReusableUI";
import JourneyMap, { JourneyMapRef } from '@/components/journey-map';
import {radar} from 'server/integrations/radar.ts'

import {
  ModernJourneyHeader,
  ModernTripPlanningCard,
  ModernActiveTripCard,
  ModernCompletedTripCard,
  ModernMessageCard
} from '@/components/ReusableUI';

interface Dealer {
  id: string;
  name: string;
  address: string;
  latitude: number;
  longitude: number;
}

interface Location {
  lat: number;
  lng: number;
  address?: string;
}

interface TripData {
  journeyId: string;
  dbJourneyId: number;
  dealer: Dealer;
  radarTrip: any;
}

export default function JourneyTracker({ onBack }: { onBack?: () => void }) {
  // ðŸ‘‡ global user from Zustand
  const { user } = useAppStore();
  const userId = user?.id;

  const [currentLocation, setCurrentLocation] = useState<Location | null>(null);
  const [selectedDealer, setSelectedDealer] = useState<Dealer | null>(null);
  const [dealers, setDealers] = useState<Dealer[]>([]);
  const [isLoadingLocation, setIsLoadingLocation] = useState(false);
  const [tripStatus, setTripStatus] = useState<'idle' | 'active' | 'completed'>('idle');
  const [activeTripData, setActiveTripData] = useState<TripData | null>(null);
  const [distance, setDistance] = useState(0);
  const [duration, setDuration] = useState(0);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');
  const [showDestinationChange, setShowDestinationChange] = useState(false);
  const [routePolyline, setRoutePolyline] = useState<[number, number][]>([]);

  const mapRef = useRef<JourneyMapRef>(null);
  const trackingIntervalRef = useRef<NodeJS.Timeout | null>(null);

  // Fetch dealers only when userId is ready
  useEffect(() => {
    if (!userId) return;
    const fetchDealers = async () => {
      try {
        const response = await fetch(`/api/dealers/user/${userId}`);
        const data = await response.json();
        if (data.success) setDealers(data.data || []);
      } catch {
        setError('Failed to load dealers');
      }
    };
    fetchDealers();
  }, [userId]);

  // Get current location
  const getCurrentLocation = async () => {
    setIsLoadingLocation(true);
    try {
      const position = await new Promise<GeolocationPosition>((resolve, reject) => {
        navigator.geolocation.getCurrentPosition(resolve, reject, {
          enableHighAccuracy: true,
          timeout: 10000,
          maximumAge: 60000
        });
      });

      const location = {
        lat: position.coords.latitude,
        lng: position.coords.longitude,
        address: 'Current Location'
      };

      setCurrentLocation(location);

      if (mapRef.current) {
        mapRef.current.setView(location.lat, location.lng, 15);
      }
    } catch (err) {
      setError('Unable to get location. Please enable GPS.');
    } finally {
      setIsLoadingLocation(false);
    }
  };

  // Start trip
  const startTrip = async () => {
    if (!currentLocation || !selectedDealer || !userId) {
      setError('Please select location and destination');
      return;
    }

    try {
      // Create trip using radar wrapper
      const radarTrip = await radar.client.createTrip({
        externalId: `${userId}-${Date.now()}`,
        userId: String(userId),
        destinationGeofenceTag: "dealer",
        destinationGeofenceExternalId: selectedDealer.id,
        mode: "car",
        originLatitude: currentLocation.lat,
        originLongitude: currentLocation.lng,
      });

      // Create DB record via your backend
      const response = await fetch('/api/geo/start', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userId,
          dealerId: selectedDealer.id,
          lat: currentLocation.lat,
          lng: currentLocation.lng,
          radarTripId: radarTrip.trip._id
        })
      });

      const data = await response.json();
      if (data.success) {
        setActiveTripData({
          journeyId: radarTrip.trip._id,
          dbJourneyId: data.data.dbJourneyId,
          dealer: selectedDealer,
          radarTrip: radarTrip.trip
        });
        setTripStatus('active');
        setSuccess('Journey started! ðŸš—');
        startLocationTracking(radarTrip.trip._id);
      } else {
        setError(data.error || 'Failed to start trip');
      }
    } catch (err: any) {
      console.error('Start trip error:', err);
      setError(`Failed to start trip: ${err.message}`);
    }
  };

  // Location tracking every 27 seconds
  const startLocationTracking = (journeyId: string) => {
    trackingIntervalRef.current = setInterval(async () => {
      try {
        const position = await new Promise<GeolocationPosition>((resolve, reject) => {
          navigator.geolocation.getCurrentPosition(resolve, reject, {
            enableHighAccuracy: true,
            timeout: 5000
          });
        });

        const newLocation = {
          lat: position.coords.latitude,
          lng: position.coords.longitude
        };

        setCurrentLocation(newLocation);

        // Get route data using radar wrapper
        try {
          const routeData = await radar.client.getTripRoute(journeyId);
          
          if (routeData.distance && routeData.duration) {
            setDistance(routeData.distance.value || 0);
            setDuration(routeData.duration.value || 0);
          }

          if (routeData.geometry && routeData.geometry.coordinates) {
            const polylinePoints = routeData.geometry.coordinates.map((coord: any) => [
              coord[1], // lat
              coord[0]  // lng
            ]);
            setRoutePolyline(polylinePoints);
          }
        } catch (routeErr) {
          console.warn('Route fetch failed:', routeErr);
        }

        // Also fetch from your backend for DB sync
        const response = await fetch(`/api/geo/trips/${journeyId}`);
        if (response.ok) {
          const data = await response.json();
          if (data.success && data.data.radarTrip) {
            const trip = data.data.radarTrip;
            if (trip.distance && trip.duration) {
              setDistance(trip.distance.value || 0);
              setDuration(trip.duration.value || 0);
            }
          }
        }
      } catch (err) {
        console.error('Tracking error:', err);
      }
    }, 27000);
  };

  // Change destination
  const changeDestination = async (newDealerId: string) => {
    if (!activeTripData) return;

    try {
      // Update trip using radar wrapper
      const radarUpdate = await radar.client.updateTrip(activeTripData.journeyId, {
        destinationGeofenceExternalId: newDealerId,
        status: "destination_updated"
      });

      // Update your backend
      const response = await fetch(`/api/geo/trips/${activeTripData.journeyId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          destinationGeofenceExternalId: newDealerId,
          status: "destination_updated"
        })
      });

      const data = await response.json();
      if (data.success) {
        const newDealer = dealers.find(d => d.id === newDealerId);
        if (newDealer) {
          setSelectedDealer(newDealer);
          setActiveTripData(prev => prev ? {
            ...prev,
            dealer: newDealer,
            radarTrip: radarUpdate.trip
          } : null);
          setSuccess('Destination updated! ðŸŽ¯');
          setShowDestinationChange(false);
          setRoutePolyline([]);
        }
      } else {
        setError(data.error || 'Failed to update');
      }
    } catch (err: any) {
      console.error('Change destination error:', err);
      setError(`Failed to change destination: ${err.message}`);
    }
  };

  // Complete trip
  const completeTrip = async () => {
    if (!activeTripData) return;

    try {
      const response = await fetch(`/api/geo/finish/${activeTripData.journeyId}`, {
        method: 'POST'
      });

      const data = await response.json();
      if (data.success) {
        setTripStatus('completed');
        setSuccess('Journey completed! ðŸŽ‰');

        if (trackingIntervalRef.current) {
          clearInterval(trackingIntervalRef.current);
          trackingIntervalRef.current = null;
        }
      } else {
        setError('Failed to complete trip');
      }
    } catch (err) {
      setError('Failed to complete trip');
    }
  };

  // Reset for new journey
  const startNewJourney = () => {
    setTripStatus('idle');
    setActiveTripData(null);
    setSelectedDealer(null);
    setDistance(0);
    setDuration(0);
    setRoutePolyline([]);
    setShowDestinationChange(false);
  };

  // Auto-hide messages
  useEffect(() => {
    if (success || error) {
      const timer = setTimeout(() => {
        setSuccess('');
        setError('');
      }, 4000);
      return () => clearTimeout(timer);
    }
  }, [success, error]);

  // Initialize
  useEffect(() => {
    getCurrentLocation();

    return () => {
      if (trackingIntervalRef.current) {
        clearInterval(trackingIntervalRef.current);
      }
    };
  }, []);

  return (
    <div className="min-h-screen bg-background">
      {/* Header */}
      <ModernJourneyHeader status={tripStatus} onBack={onBack} />

      {/* Messages */}
      {success && <ModernMessageCard type="success" message={success} />}
      {error && <ModernMessageCard type="error" message={error} />}

      {/* Main Content - Clean Layout */}
      <div className="container max-w-md mx-auto p-4 space-y-4">
        {/* Contained Map */}
        <JourneyMap
          ref={mapRef}
          currentLocation={currentLocation}
          selectedDealer={selectedDealer}
          routePolyline={routePolyline}
          className="w-full"
        />

        {/* Trip UI Cards */}
        {tripStatus === 'idle' && (
          <ModernTripPlanningCard
            currentLocation={currentLocation?.address}
            selectedDealer={selectedDealer}
            dealers={dealers}
            isLoadingLocation={isLoadingLocation}
            onGetCurrentLocation={getCurrentLocation}
            onDealerSelect={(dealerId) => {
              const dealer = dealers.find(d => d.id === dealerId);
              setSelectedDealer(dealer || null);
            }}
            onStartTrip={startTrip}
          />
        )}

        {tripStatus === 'active' && activeTripData && (
          <ModernActiveTripCard
            dealer={activeTripData.dealer}
            distance={distance}
            duration={duration}
            onChangeDestination={() => setShowDestinationChange(true)}
            onCompleteTrip={completeTrip}
            showDestinationChange={showDestinationChange}
            dealers={dealers}
            onDestinationChange={changeDestination}
            onCancelChange={() => setShowDestinationChange(false)}
          />
        )}

        {tripStatus === 'completed' && (
          <ModernCompletedTripCard
            distance={distance}
            duration={duration}
            onStartNew={startNewJourney}
          />
        )}
      </div>
    </div>
  );
}